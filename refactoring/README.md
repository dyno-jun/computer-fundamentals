# 리팩토링 기법 (Refactoring Techniques)

## 1. 함수 추출하기 (Extract Method)

### 목적

- 코드의 특정 부분을 별도의 함수로 추출하여 코드의 가독성을 높이고 재사용성을 증가시키는 기법입니다.

### 효과

- 코드가 간결해지고 이해하기 쉬워짐.
- 중복을 줄이고 테스트 용이성이 증가함.

### 절차

1. 추출하려는 코드를 선택.
2. 선택한 코드가 다른 코드와 독립적으로 작동하는지 확인.
3. 새 함수를 생성하고 선택한 코드를 복사.
4. 기존 코드를 새 함수 호출로 대체.
5. 테스트를 통해 동작 확인.

---

## 2. 변수 인라인하기 (Inline Variable)

### 목적

- 의미가 없거나 코드의 가독성을 떨어뜨리는 임시 변수를 없애고, 그 값을 직접 사용하도록 바꾸는 기법입니다.

### 효과

- 불필요한 간접 참조를 줄여 코드의 단순성을 높임.
- 코드가 더 직관적으로 변경됨.

### 절차

1. 변수를 사용하는 모든 곳을 해당 값으로 대체.
2. 변수를 삭제.
3. 테스트를 통해 변경 확인.

---

## 3. 문장 슬라이스 하기 (Split Phase)

### 목적

- 하나의 함수나 메서드가 여러 단계의 작업을 수행할 때, 각 단계를 별도의 함수로 분리하는 기법입니다.

### 효과

- 각 단계의 의미가 명확히 드러나며 유지보수성이 향상됨.
- 테스트 가능성이 높아짐.

### 절차

1. 단계를 분석하여 분리 가능한 작업을 식별.
2. 각 단계를 별도의 함수로 작성.
3. 기존 로직을 각 단계 함수 호출로 대체.
4. 전체 동작과 개별 단계를 테스트.

---

## 4. 조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)

### 목적

- 조건문으로 구현된 로직을 다형성을 사용하여 각 조건에 따라 서로 다른 클래스를 만들어 처리하는 기법입니다.

### 효과

- 조건문을 줄여 코드가 더 직관적이고 확장하기 쉬워짐.
- 클래스 구조로 변경하여 독립적인 조건 처리가 가능해짐.

### 절차

1. 조건문이 있는 로직을 분석.
2. 조건별 클래스를 생성하고 공통 인터페이스를 정의.
3. 조건문을 다형성을 활용한 메서드 호출로 변경.
4. 테스트를 통해 동작 확인.

---

## 5. 함수 옮기기 (Move Method)

### 목적

- 특정 클래스에 속해 있는 함수가 다른 클래스에서 더 잘 맞는 경우, 그 함수를 적절한 클래스나 모듈로 옮기는 기법입니다.

### 효과

- 데이터와 로직이 서로 잘 맞아야 코드가 더 직관적이고 유지보수하기 쉬워짐.
- 함수의 응집도가 높아지고 결합도가 낮아짐.

### 절차

1. 이동할 함수가 사용하는 데이터와 참조를 확인.
2. 대상 클래스에 새 함수를 작성하고 기존 로직을 복사.
3. 기존 함수를 새 함수 호출로 대체.
4. 호출하는 모든 코드를 새 함수로 업데이트.
5. 기존 함수를 삭제하고 테스트.

---

## 6. 단계 쪼개기 (Split Phase)

### 목적

- 복잡한 처리를 단계별로 나누어 각각의 단계가 명확히 드러나도록 하는 기법입니다.

### 효과

- 각 단계가 독립적이고 테스트하기 쉬워짐.
- 로직의 흐름을 쉽게 파악할 수 있음.

### 절차

1. 단계별로 코드를 분석하여 분리 가능한 작업을 식별.
2. 각 단계를 별도의 함수로 작성.
3. 기존 로직을 각 단계 함수 호출로 대체.
4. 각 단계와 전체 동작을 테스트.

---

# 리팩토링 2판 요약

## 리팩토링 정의

### 목적

- 코드의 외부 동작을 유지하면서 내부 구조를 개선.

### 효과

- **가독성**과 **유지보수성**이 향상됨.
- **코드 복잡도**가 감소하여 새로운 기능 추가 및 버그 수정이 용이해짐.

### 절차

1. 현재 코드의 동작을 파악.
2. 기존 동작을 보장할 수 있도록 테스트 작성.
3. 내부 구조를 개선하면서 테스트를 반복 실행.

---

## 두 개의 모자

### 목적

- 개발자가 **기능 추가**와 **리팩토링**이라는 두 가지 역할을 명확히 구분하여 작업.

### 효과

- 기능 추가 작업과 코드 구조 개선 작업이 명확히 분리되어 효율성과 품질이 모두 향상됨.
- 두 역할 간의 충돌을 방지하여 작업에 집중할 수 있음.

### 절차

1. 기능 추가 시에는 구조 개선을 미루고 요구사항 구현에 집중.
2. 리팩토링 시에는 기존 동작을 변경하지 않고 코드 구조를 개선.
3. 각 작업에 대한 명확한 경계를 설정.

---

## 리팩토링 하는 이유

### 목적

- 시간이 지나면서 증가하는 코드 복잡도를 줄이고 유지보수를 용이하게 함.

### 효과

- **팀 협업**이 원활해지고, 코드 품질이 향상됨.
- **기술 부채**가 감소하여 장기적으로 유지보수 비용 절감.
- 변경 사항 반영과 버그 수정이 더 쉬워짐.

### 절차

1. 코드에서 **문제점(Code Smells)**을 식별.
2. 문제를 해결하기 위해 적절한 리팩토링 기법을 선택.
3. 테스트를 작성하고 리팩토링을 반복 수행.

---

## 언제 리팩토링을 해야 할까?

### 목적

- 코드에서 리팩토링이 필요한 신호를 식별하고 적절한 시점에 실행.

### 효과

- 코드의 구조와 품질이 지속적으로 개선됨.
- 기능 추가 및 버그 수정이 용이해지고 안정성을 유지.

### 절차

1. 다음 신호를 식별:
    - 중복 코드, 긴 함수, 긴 매개변수 목록, 큰 클래스 등.
2. 적절한 시점에 리팩토링 실행:
    - 기능 추가 전, 버그 수정 전, 코드 리뷰 후.
3. 테스트를 통해 동작을 검증하며 개선 반복.

---

## 리팩토링 시 고려할 문제

### 목적

- 리팩토링 중 발생할 수 있는 위험 요소를 사전에 인지하고 해결 방안을 마련.

### 효과

- 리팩토링의 안정성을 확보하고 팀 내 공감을 형성.
- 불필요한 작업을 방지하여 생산성을 유지.

### 절차

1. **테스트 부족** 문제를 해결하기 위해 리팩토링 전후 테스트 작성.
2. **과도한 리팩토링**을 방지하기 위해 필요한 부분만 개선.
3. 팀 내 **공감대 형성**을 위해 계획과 목표를 공유.

---

## 리팩토링, 아키텍처, 애그니

### 목적

- 리팩토링을 통해 변화하는 요구사항에 맞는 유연한 아키텍처를 구축.

### 효과

- 시스템 복잡도를 줄이고, 변경에 유연하게 대응할 수 있음.
- 설계의 명확성을 높이고 유지보수성을 강화.

### 절차

1. 코드에서 반복적으로 나타나는 문제 패턴을 식별.
2. 리팩토링 기법을 적용하여 설계를 개선.
3. 테스트를 통해 변경 사항을 검증.

---

## 리팩토링과 소프트웨어 개발 프로세스

### 목적

- 리팩토링을 소프트웨어 개발 프로세스에 통합하여 품질을 지속적으로 유지.

### 효과

- 애자일 개발과 테스트 주도 개발(TDD)에 리팩토링이 적합하게 결합됨.
- 코드의 안정성과 품질이 장기적으로 유지됨.

### 절차

1. **애자일 개발**에서 짧은 주기 동안 지속적으로 코드 개선.
2. **TDD**를 활용하여 테스트 작성 후 리팩토링 수행.
3. 개발 과정에서 발견된 문제를 해결하며 리팩토링 반복.

---

## 리팩토링과 성능

### 목적

- 코드 구조 개선을 통해 성능 문제를 더 쉽게 발견하고 해결.

### 효과

- 코드 구조를 명확히 하여 성능 최적화 작업이 간단해짐.
- 성능 문제를 해결하기 위한 기반이 마련됨.

### 절차

1. 리팩토링으로 코드 구조를 단순화.
2. 성능 문제를 분석하고 최적화 작업 진행.
3. 테스트를 통해 개선된 성능을 검증.

---

## 리팩토링의 유래

### 목적

- 리팩토링 기법의 역사를 이해하고, 현대 개발에서 중요성을 인식.

### 효과

- 리팩토링의 이론적 배경을 알고 활용도를 높임.
- 소프트웨어 개발의 필수적 기법으로 리팩토링을 적극 활용.

### 절차

1. 리팩토링의 초기 개념과 발전 과정을 학습.
2. 마틴 파울러(Martin Fowler) 등의 선구적인 사례를 참고.
3. 이를 소프트웨어 개발에 적용.

---

## 리팩토링 자동화

### 목적

- 현대적인 도구를 활용하여 리팩토링 작업을 효율적으로 수행.

### 효과

- 반복 작업을 자동화하여 시간과 노력을 절약.
- 안정성과 신뢰성을 높임.

### 절차

1. IntelliJ IDEA, Eclipse 등 현대 IDE의 리팩토링 기능 활용.
2. 자동화 도구를 사용하여 안전하게 코드 변경.
3. 도구가 제공하는 변경 사항을 검토하고 테스트를 수행.

---

# 리팩토링 2판 3장: 코드에서 나는 악취

## 3.1 기이한 이름 (Mysterious Name)

### 목적

- 이름이 모호하거나 의도가 명확하지 않은 경우, 더 의미 있고 직관적인 이름으로 변경.

### 효과

- 코드의 가독성과 유지보수성이 향상됨.
- 코드의 의도를 더 명확히 전달할 수 있음.

### 절차

1. 이름이 모호하거나 적절하지 않은 식별자를 식별.
2. 새로운 이름을 정의하여 교체.
3. 이름 변경 후 코드 전반에 반영하고 테스트.

---

## 3.2 중복 코드 (Duplicated Code)

### 목적

- 여러 곳에서 동일한 코드가 반복될 때, 이를 제거하고 재사용 가능한 코드로 통합.

### 효과

- 중복 코드를 줄여 유지보수성을 향상.
- 코드 변경 시 수정해야 할 부분을 줄여 오류 가능성 감소.

### 절차

1. 중복된 코드를 식별.
2. 공통된 로직을 별도의 함수나 클래스로 추출.
3. 중복된 부분을 새로 추출한 코드로 대체하고 테스트.

---

## 3.3 긴 함수 (Long Function)

### 목적

- 긴 함수를 더 작고 명확한 여러 함수로 나누어 가독성과 재사용성을 높임.

### 효과

- 코드가 간결해지고 이해하기 쉬워짐.
- 유지보수성과 테스트 용이성이 향상됨.

### 절차

1. 함수를 분석하여 논리적으로 묶을 수 있는 코드를 식별.
2. 해당 코드를 별도의 함수로 추출.
3. 원래 코드를 새 함수 호출로 대체하고 테스트.

---

## 3.4 긴 매개변수 목록 (Long Parameter List)

### 목적

- 매개변수 개수를 줄이고, 관련 매개변수를 객체로 묶어 관리.

### 효과

- 함수 호출이 간단해지고, 매개변수 간의 관계를 명확히 표현 가능.
- 매개변수 목록 변경 시 영향 범위를 줄임.

### 절차

1. 자주 함께 사용되는 매개변수를 식별.
2. 관련 매개변수를 포함하는 클래스를 정의.
3. 기존 함수의 매개변수를 새 객체로 대체하고 테스트.

---

## 3.5 전역 데이터 (Global Data)

### 목적

- 전역 변수의 사용을 최소화하고, 데이터를 캡슐화하여 부작용을 줄임.

### 효과

- 데이터 접근 방식을 통제하여 예기치 않은 변경을 방지.
- 데이터의 의도를 더 명확히 표현 가능.

### 절차

1. 전역 변수를 캡슐화할 클래스를 생성.
2. 변수를 읽고 쓰는 메서드를 정의.
3. 기존 전역 변수 참조를 새 클래스의 메서드로 대체하고 테스트.

---

## 3.6 가변 데이터 (Mutable Data)

### 목적

- 데이터 변경 가능성을 줄이고, 불변 데이터를 사용하여 코드의 신뢰성을 높임.

### 효과

- 데이터 변경 추적이 쉬워지고, 사이드 이펙트를 줄일 수 있음.
- 멀티스레드 환경에서 데이터 안정성을 보장.

### 절차

1. 데이터 변경이 필요한지 분석.
2. 변경이 필요하지 않은 데이터를 불변 객체로 변경.
3. 불변 객체를 사용하는 코드를 수정하고 테스트.

---

## 3.7 뒤엉킨 변경 (Divergent Change)

### 목적

- 하나의 클래스가 여러 가지 이유로 변경될 때, 책임을 분리하여 단일 책임 원칙(SRP)을 준수.

### 효과

- 각 클래스가 하나의 변경 이유만 가지도록 하여 유지보수성 향상.
- 변경 범위를 좁혀 오류 가능성을 줄임.

### 절차

1. 클래스가 여러 책임을 수행하는지 분석.
2. 각 책임을 별도의 클래스로 분리.
3. 기존 코드를 분리된 클래스에 맞게 수정하고 테스트.

---

## 3.8 산탄총 수술 (Shotgun Surgery)

### 목적

- 하나의 변경이 여러 클래스에 영향을 미치는 경우, 관련된 기능을 한 곳으로 모아 관리.

### 효과

- 변경 범위를 줄여 유지보수성을 높임.
- 기능 관련성을 높여 코드의 응집도를 향상.

### 절차

1. 변경 시 영향을 받는 클래스들을 식별.
2. 관련 기능을 한 클래스 또는 모듈로 이동.
3. 기존 코드를 수정하고 테스트.

---

## 3.9 기능 편애 (Feature Envy)

### 목적

- 특정 클래스가 다른 클래스의 데이터에 지나치게 의존하는 경우, 데이터를 소유한 클래스가 관련 동작을 처리하도록 수정.

### 효과

- 데이터와 동작이 한 클래스에 응집되어 코드의 직관성과 유지보수성이 향상됨.
- 결합도를 낮춰 코드 구조를 개선.

### 절차

1. 기능 편애가 발생한 코드를 식별.
2. 데이터를 소유한 클래스에 새로운 메서드를 정의.
3. 기존 코드를 새 메서드 호출로 대체하고 테스트.

---

## 3.10 데이터 뭉치 (Data Clumps)

### 목적

- 항상 함께 사용되는 데이터를 객체로 묶어 관계를 명확히 표현.

### 효과

- 데이터 구조가 간단해지고, 관련 데이터 관리가 쉬워짐.
- 데이터 변경 시 영향을 줄임.

### 절차

1. 함께 사용되는 데이터 필드를 식별.
2. 데이터를 포함하는 클래스를 생성.
3. 기존 필드를 새 객체로 대체하고 테스트.

---

## 3.11 기본형 집착 (Primitive Obsession)

### 목적

- 기본 데이터 타입만을 고집하여 도메인 개념을 표현하지 못하는 경우, 이를 객체로 변경.

### 효과

- 도메인 개념을 명확히 표현하고, 관련 동작을 캡슐화하여 응집도 향상.
- 중복 코드가 줄어들고 유지보수성이 향상됨.

### 절차

1. 기본형으로 표현된 데이터를 분석.
2. 해당 데이터를 표현하는 클래스를 생성.
3. 기존 코드를 새 클래스를 사용하도록 변경하고 테스트.

---

## 3.12 반복되는 switch문 (Repeated Switch Statements)

### 목적

- 조건문을 다형성을 활용하여 제거하고, 중복된 로직을 최소화.

### 효과

- 코드 가독성과 유지보수성이 향상됨.
- 새로운 조건 추가 시 변경 범위를 최소화.

### 절차

1. 반복되는 switch문을 분석.
2. 조건별 클래스를 생성하고 공통 인터페이스를 정의.
3. switch문을 다형성을 활용한 메서드 호출로 대체하고 테스트.

---

## 3.13 반복문 (Loops)

### 목적

- 반복문 대신 함수형 프로그래밍 스타일의 추상화를 사용하여 가독성을 높임.

### 효과

- 반복문 로직을 더 직관적으로 표현 가능.
- 코드 길이가 줄어들고 유지보수성이 향상됨.

### 절차

1. 반복문의 목적과 처리 로직을 분석.
2. 스트림(`map`, `filter`, `reduce`) 등 고수준 추상화를 사용하여 로직 변환.
3. 기존 반복문을 제거하고 테스트.

---

## 3.14 성의없는 요소 (Lazy Element)

### 목적

- 의미가 부족한 클래스나 메서드를 제거하여 코드 간결성을 높임.

### 효과

- 코드베이스가 단순화되고, 유지보수성이 향상됨.

### 절차

1. 의미가 부족한 요소를 식별.
2. 요소를 제거하거나, 더 의미 있는 곳으로 통합.
3. 변경 후 테스트.

---

## 3.15 추측성 일반화 (Speculative Generality)

### 목적

- 필요하지 않은 일반화를 제거하여 현재 요구사항에 집중.

### 효과

- 코드가 간단해지고, 불필요한 복잡도가 감소.

### 절차

1. 사용되지 않는 일반화 코드를 식별.
2. 해당 코드를 제거하고, 현재 요구사항에 맞게 단순화.
3. 테스트를 통해 변경 확인.

---

## 3.16 임시 필드 (Temporary Field)

### 목적

- 특정 상황에서만 값이 있는 필드를 제거하거나, 관련 로직으로 제한.

### 효과

- 불필요한 필드 제거로 코드 간결성 향상.
- 코드 이해가 쉬워지고 유지보수성 증가.

### 절차

1. 임시 필드를 식별.
2. 필드를 제거하거나, 필요한 메서드 내로 이동.
3. 변경 사항 테스트.

---

## 3.17 메시지 체인 (Message Chains)

### 목적

- 여러 객체를 연속적으로 호출하는 체인을 캡슐화하여 결합도를 낮춤.

### 효과

- 코드 가독성과 유지보수성이 향상됨.
- 클라이언트 코드와 내부 구조 간 결합도를 줄임.

### 절차

1. 메시지 체인을 식별.
2. 체인을 캡슐화하는 메서드를 정의.
3. 기존 코드를 새 메서드 호출로 대체하고 테스트.

---

## 3.18 중개자 (Middle Man)

### 목적

- 불필요한 중개자 메서드를 제거하여 성능과 가독성을 개선.

### 효과

- 코드 간접 참조를 줄여 단순화.
- 유지보수성이 향상됨.

### 절차

1. 중개자 메서드를 식별.
2. 해당 메서드를 직접 호출로 대체.
3. 중개자를 제거하고 테스트.

---

## 3.19 내부자 거래 (Insider Trading)

### 목적

- 두 클래스가 내부 정보를 지나치게 공유하지 않도록 캡슐화.

### 효과

- 클래스 간 결합도를 줄이고, 데이터 접근 방식을 제어.

### 절차

1. 내부자 거래가 발생하는 부분을 식별.
2. 캡슐화를 통해 접근 방식을 변경.
3. 코드 수정 후 테스트.

---

## 3.20 거대한 클래스 (Large Class)

### 목적

- 책임이 과도한 클래스를 분리하여 단일 책임 원칙(SRP)을 준수.

### 효과

- 클래스 구조가 간단해지고, 가독성과 유지보수성이 향상됨.

### 절차

1. 클래스를 분석하여 분리 가능한 책임을 식별.
2. 새로운 클래스를 생성하고 해당 책임을 이동.
3. 기존 코드를 수정하고 테스트.

---

## 3.21 데이터 클래스 (Data Class)

### 목적

- 데이터만 저장하는 클래스에 동작을 추가하여 의미를 부여.

### 효과

- 객체지향 원칙을 준수하며, 클래스가 더 유용해짐.

### 절차

1. 데이터를 저장하는 클래스에서 관련 동작을 추가.
2. 관련된 로직을 새 메서드로 이동.
3. 기존 코드를 수정하고 테스트.

# 리팩토링 4장 요약: 테스트를 통한 코드 개선

## 4.1 자가 테스트 코드의 가치

### 목적

- 리팩토링 중 코드의 안정성을 유지하기 위해 자가 테스트 코드를 작성.
- 코드 변경 시 문제 발생 여부를 빠르게 확인할 수 있는 안전망 역할 수행.

### 효과

- 코드 품질과 유지보수성이 향상됨.
- 코드 변경에 대한 자신감을 높이고, 오류 발생 가능성을 줄임.

### 절차

1. 리팩토링 대상 코드의 현재 동작을 이해.
2. 코드의 예상 동작을 검증할 수 있는 자가 테스트 코드 작성.
3. 리팩토링 이후 테스트를 반복 실행하여 기존 동작 유지 확인.

---

## 4.2 테스트할 샘플 코드

### 목적

- 복잡하거나 긴 코드를 이해하고 유지보수하기 쉽게 리팩토링하기 위한 테스트 준비.
- 리팩토링 대상 코드의 핵심 동작을 명확히 파악.

### 효과

- 코드의 작동 방식과 개선 방향을 명확히 이해.
- 리팩토링 작업에 대한 명확한 테스트 기준 제공.

### 절차

1. 리팩토링 대상 코드의 입력과 출력을 분석.
2. 해당 코드에 대한 테스트 케이스 작성.
3. 코드의 정상 동작을 확인하고 리팩토링 준비.

---

## 4.3 첫 번째 테스트

### 목적

- 리팩토링 시작 전에 기본적인 테스트를 작성하여 코드의 정상 동작을 검증.

### 효과

- 코드 변경 중 발생할 수 있는 오류를 사전에 방지.
- 테스트를 통해 코드의 의도와 기대 결과를 명확히 정의.

### 절차

1. 리팩토링 대상 코드의 기본 동작을 검증할 테스트 케이스 작성.
2. 테스트를 실행하여 기존 코드의 정상 동작 확인.
3. 테스트 결과를 바탕으로 리팩토링 준비.

---

## 4.4 테스트 추가하기

### 목적

- 다양한 시나리오를 커버하기 위해 추가적인 테스트 케이스 작성.
- 코드가 여러 상황에서도 안정적으로 동작하는지 확인.

### 효과

- 코드의 신뢰성과 안정성을 높임.
- 엣지 케이스와 잠재적 오류를 사전에 식별.

### 절차

1. 다양한 입력 데이터와 시나리오를 분석.
2. 추가 테스트 케이스 작성 및 실행.
3. 테스트 결과를 바탕으로 코드 안정성 검증.

---

## 4.5 픽스처 수정하기

### 목적

- 테스트 데이터(픽스처)를 정리하고 재사용성을 높임.
- 반복적으로 사용되는 데이터를 간소화하여 테스트 코드의 가독성을 개선.

### 효과

- 테스트 코드가 간결하고 유지보수하기 쉬워짐.
- 변경 사항에 쉽게 적응 가능.

### 절차

1. 테스트에서 반복적으로 사용되는 데이터를 식별.
2. 공통 데이터를 픽스처로 정리하여 재사용.
3. 기존 테스트를 픽스처를 활용하도록 수정.

---

## 4.6 경계 조건 검사하기

### 목적

- 데이터가 최소값, 최대값, 혹은 예외적인 조건일 때 코드가 올바르게 동작하는지 검증.

### 효과

- 코드의 강건성을 확보하고, 경계 조건에서 발생할 수 있는 오류를 방지.
- 경계 상황에 대한 코드의 안정성과 신뢰성을 높임.

### 절차

1. 코드에서 처리해야 할 경계 조건 식별.
2. 경계 조건에 대한 테스트 케이스 작성.
3. 테스트를 실행하여 코드의 안정성 확인.

---

## 4.7 끝나지 않은 여정

### 목적

- 리팩토링 과정에서 지속적으로 테스트를 추가하고 개선하여 코드 품질을 유지.

### 효과

- 테스트를 통해 코드 변경에 대한 신뢰를 제공.
- 더 나은 코드와 시스템을 유지하기 위한 지속적인 개선 가능.

### 절차

1. 리팩토링 이후에도 새로운 테스트 케이스를 지속적으로 작성.
2. 테스트를 통해 코드 변경 사항을 반복적으로 검증.
3. 코드 품질을 유지하며 점진적으로 개선.

---

# 리팩토링 5장 요약: 리팩토링을 위한 카탈로그 소개

## 5.1 리팩토링의 기본 원칙

### 목적

- 소프트웨어의 구조를 개선하여 유지보수성과 확장성을 높임.
- 소프트웨어 품질 향상을 위한 다양한 리팩토링 기법을 체계적으로 소개.

### 효과

- 코드의 **가독성**과 **유지보수성**이 크게 향상됨.
- 리팩토링 과정에서 코드의 안정성과 품질을 보장할 수 있음.

### 절차

1. 리팩토링의 목적과 필요성을 명확히 이해.
2. 리팩토링 카탈로그를 사용해 문제에 적합한 기법을 선택.
3. 각 기법의 절차를 따라 리팩토링 수행.
4. 리팩토링 후 테스트를 통해 코드 동작 확인.

---

## 5.2 리팩토링 기법의 분류

### 목적

- 다양한 리팩토링 기법을 체계적으로 분류하여 문제 해결에 적합한 기법을 빠르게 찾을 수 있도록 도움.

### 효과

- 각 기법의 목적과 효과를 명확히 이해할 수 있음.
- 리팩토링을 체계적이고 효율적으로 수행 가능.

### 절차

1. 코드에서 문제점을 식별.
2. 카탈로그에서 문제 해결에 적합한 리팩토링 기법 탐색.
3. 기법의 절차를 따라 문제 해결.
4. 코드 변경 후 동작을 검증.

---

## 5.3 리팩토링 카탈로그의 주요 항목

### 목적

- 자주 사용되는 리팩토링 기법을 정리하고, 각 기법의 사용 방법과 효과를 명확히 설명.

### 효과

- 문제 해결에 적합한 기법을 신속하게 선택 가능.
- 기법별로 구체적인 절차를 따라 안정적으로 리팩토링 가능.

### 절차

1. 각 기법의 정의와 목적을 학습.
2. 코드의 문제를 분석하여 적용 가능한 기법을 선택.
3. 리팩토링 절차를 따라 코드를 개선.
4. 테스트를 통해 변경 사항 확인.

---

## 5.4 리팩토링 기법의 적용 기준

### 목적

- 코드의 안정성을 유지하면서, 효율적으로 리팩토링을 수행할 수 있는 기준을 제시.

### 효과

- 리팩토링이 필요한 경우와 필요하지 않은 경우를 구분 가능.
- 불필요한 리팩토링을 방지하여 생산성 유지.

### 절차

1. 리팩토링이 필요한 신호(Code Smells)를 식별.
2. 리팩토링이 적합한 상황인지 평가.
3. 필요할 경우, 리팩토링 기법을 적용.
4. 리팩토링 후, 코드의 개선 여부를 확인.

---

## 5.5 리팩토링의 한계와 주의점

### 목적

- 리팩토링 과정에서 발생할 수 있는 위험과 한계를 인식하고, 이를 효과적으로 관리.

### 효과

- 리팩토링 과정에서 발생할 수 있는 문제를 최소화.
- 리팩토링의 한계를 이해하여 불필요한 작업을 방지.

### 절차

1. 리팩토링 시 발생할 수 있는 위험 요소를 분석.
2. 충분한 테스트를 통해 변경 사항을 안정적으로 검증.
3. 리팩토링의 필요성과 한계를 명확히 이해하고 작업 범위 조정.
4. 코드 품질이 향상되었는지 평가.

---

## 5.6 리팩토링의 지속적 활용

### 목적

- 리팩토링을 지속적으로 활용하여 코드 품질과 시스템 유연성을 유지.

### 효과

- 장기적인 코드 품질 향상.
- 유지보수성과 확장성을 지속적으로 확보.

### 절차

1. 개발 프로세스에 리팩토링을 통합.
2. 변경 사항이 발생할 때마다 리팩토링 수행.
3. 정기적으로 코드 품질을 점검하고 개선.
4. 테스트를 통해 안정성을 확인하며 리팩토링 반복.

---

# 리팩토링 6장: 기본적인 리팩터링

## 6.1 함수 추출하기 (Extract Method)

### 목적

- 복잡한 코드를 이해하기 쉽게 만들기 위해, 코드의 특정 부분을 별도의 함수로 분리.

### 효과

- 코드의 가독성이 향상되고, 중복을 줄일 수 있음.
- 코드 재사용성과 유지보수성이 높아짐.

### 절차

1. 추출하려는 코드 블록을 식별.
2. 새 함수를 생성하고 코드를 복사.
3. 원래 코드를 새 함수 호출로 대체.
4. 테스트를 실행하여 변경 사항 확인.

---

## 6.2 함수 인라인하기 (Inline Method)

### 목적

- 의미 없는 간접 호출을 제거하여 코드의 단순성과 명확성을 높임.

### 효과

- 함수 호출을 제거하여 간접 참조를 줄이고, 코드의 명확성을 높임.
- 불필요한 함수 정의를 제거하여 코드 간결화.

### 절차

1. 인라인하려는 함수 호출을 확인.
2. 호출부에 함수의 본문을 직접 삽입.
3. 인라인된 함수를 삭제.
4. 테스트를 실행하여 코드 변경 확인.

---

## 6.3 변수 추출하기 (Extract Variable)

### 목적

- 복잡한 표현식을 변수로 추출하여 코드의 가독성과 명확성을 높임.

### 효과

- 복잡한 코드를 읽기 쉽게 만들고, 표현식이 반복되는 경우 중복 제거 가능.
- 코드를 이해하고 유지보수하기 쉬워짐.

### 절차

1. 추출하려는 표현식을 선택.
2. 표현식 결과를 저장할 변수를 선언하고 값을 할당.
3. 원래 표현식을 변수로 대체.
4. 테스트를 실행하여 코드 변경 확인.

---

## 6.4 변수 인라인하기 (Inline Variable)

### 목적

- 명확성을 더하지 않는 임시 변수를 제거하여 코드 단순화.

### 효과

- 불필요한 변수를 제거하여 코드가 간결해지고, 유지보수성이 향상됨.
- 변수의 불필요한 사용을 줄여 오류 가능성을 감소.

### 절차

1. 변수의 모든 참조를 값으로 대체.
2. 변수를 제거.
3. 테스트를 실행하여 변경 사항 확인.

---

## 6.5 함수 이름 바꾸기 (Rename Method)

### 목적

- 함수의 이름을 더 명확하고 의미 있는 이름으로 변경하여 코드의 가독성을 높임.

### 효과

- 함수의 목적이 명확해지고, 코드를 더 쉽게 이해할 수 있음.
- 코드 탐색 및 유지보수가 용이해짐.

### 절차

1. 더 적합한 이름을 선택.
2. 함수 정의와 호출부에서 이름 변경.
3. 변경 사항에 대해 테스트 실행.

---

## 6.6 변수 캡슐화하기 (Encapsulate Variable)

### 목적

- 변수를 직접 접근하지 않고, getter와 setter 메서드를 통해 접근을 제어.

### 효과

- 데이터 접근 방식을 통제할 수 있으며, 이후 요구사항 변경에 유연하게 대처 가능.
- 데이터 무결성을 보장.

### 절차

1. 변수를 private로 변경.
2. getter와 setter 메서드 생성.
3. 기존 변수를 사용하는 부분을 메서드 호출로 대체.
4. 테스트를 실행하여 변경 확인.

---

## 6.7 변수 이름 바꾸기 (Rename Variable)

### 목적

- 변수에 더 명확하고 직관적인 이름을 부여하여 코드 가독성을 향상.

### 효과

- 변수의 역할과 용도가 명확해져, 코드 이해가 쉬워짐.
- 유지보수성과 협업 생산성 향상.

### 절차

1. 변수의 의미를 가장 잘 표현할 이름을 선택.
2. 모든 참조에서 이름 변경.
3. 변경 사항을 테스트하여 코드 안정성 확인.

---

## 6.8 매개변수 객체 만들기 (Introduce Parameter Object)

### 목적

- 관련된 매개변수들을 객체로 묶어 매개변수 간의 관계를 명확히 하고 관리 용이성을 높임.

### 효과

- 매개변수의 개수를 줄여 함수 호출이 간단해짐.
- 매개변수 간의 관계를 명확히 드러냄.

### 절차

1. 자주 함께 사용되는 매개변수를 식별.
2. 관련 매개변수를 포함하는 클래스를 정의.
3. 기존 함수의 매개변수를 새 객체로 교체.
4. 테스트를 실행하여 변경 확인.

---

## 6.9 여러 함수를 클래스로 묶기 (Extract Class)

### 목적

- 동일한 데이터를 처리하는 여러 함수를 하나의 클래스로 묶어 응집도를 높임.

### 효과

- 클래스의 책임이 명확해지고, 유지보수성이 향상됨.
- 객체 지향 설계를 통해 코드 구조 개선.

### 절차

1. 관련된 함수를 식별.
2. 새로운 클래스를 생성하고 해당 함수를 메서드로 이동.
3. 함수가 사용하는 데이터를 클래스의 인스턴스 변수로 이동.
4. 기존 코드를 수정하여 새 클래스를 참조하도록 변경.
5. 테스트를 실행하여 변경 사항 확인.

---

## 6.10 여러 함수를 변환 함수로 묶기 (Introduce Transform Function)

### 목적

- 데이터 변환과 관련된 여러 함수를 하나의 변환 함수로 결합하여 관리와 이해를 용이하게 함.

### 효과

- 데이터 처리 로직이 명확해지고, 중복이 줄어듦.
- 변환 로직을 쉽게 확장할 수 있음.

### 절차

1. 데이터를 변환하는 관련 함수들을 식별.
2. 변환 로직을 하나의 함수로 결합.
3. 기존 코드를 변환 함수 호출로 대체.
4. 테스트를 실행하여 변경 확인.

---

## 6.11 단계 쪼개기 (Split Phase)

### 목적

- 복잡한 프로세스를 잘 정의된 단계로 나누어 관리와 테스트를 용이하게 함.

### 효과

- 각 단계가 명확히 드러나며, 유지보수성과 테스트 용이성이 향상됨.
- 코드가 단순해지고 이해하기 쉬워짐.

### 절차

1. 프로세스에서 논리적으로 구분할 수 있는 단계를 식별.
2. 각 단계를 별도의 함수로 구현.
3. 기존 코드를 각 단계 호출로 대체.
4. 전체 동작과 각 단계를 테스트.

# 7장 캡슐화

## 7.1 레코드 캡슐화 하기 (Encapsulate Record)

### 목적

- 데이터 구조를 캡슐화하여 변경 가능성을 줄이고, 데이터 접근과 수정 방법을 제어합니다.

### 효과

- 데이터 접근 방식을 일관되게 유지할 수 있습니다.
- 데이터를 안전하게 보호하고, 이후 요구사항 변경에 유연하게 대처할 수 있습니다.

### 절차

1. 데이터를 포함하는 클래스를 정의합니다.
2. 해당 클래스에 데이터를 읽고 쓸 수 있는 접근자(Getter/Setter)를 만듭니다.
3. 기존 코드에서 데이터 필드 접근을 캡슐화된 접근 메서드로 교체합니다.

---

## 7.2 컬렉션 캡슐화 하기 (Encapsulate Collection)

### 목적

- 컬렉션 데이터에 직접 접근하지 않고, 제어된 방식으로 데이터를 추가하거나 제거하도록 만듭니다.

### 효과

- 컬렉션에 대한 무분별한 접근을 막아 데이터 무결성을 유지합니다.
- 컬렉션 사용 방식을 일관되게 관리할 수 있습니다.

### 절차

1. 컬렉션을 저장하는 필드에 접근자(Getter/Setter)를 추가합니다.
2. 컬렉션을 조작하는 메서드(예: `addItem`, `removeItem`)를 생성합니다.
3. 외부 코드에서 직접 컬렉션을 조작하던 부분을 새로운 메서드로 대체합니다.

---

## 7.3 기본형을 객체로 바꾸기 (Replace Primitive with Object)

### 목적

- 기본형으로 표현된 데이터를 객체로 변환하여 의미를 명확히 하고, 관련된 동작을 캡슐화합니다.

### 효과

- 데이터와 관련된 로직을 객체 내부로 이동시켜 응집도를 높이고, 코드 중복을 줄일 수 있습니다.
- 도메인 개념을 명확히 표현할 수 있습니다.

### 절차

1. 데이터를 나타내는 클래스를 생성합니다.
2. 기본형 데이터를 새 클래스로 대체합니다.
3. 기존 코드를 점진적으로 수정하여 새 클래스를 사용하도록 변경합니다.

---

## 7.4 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)

### 목적

- 임시 변수의 값을 계산하는 로직을 질의 함수로 이동하여 중복을 제거하고 가독성을 향상시킵니다.

### 효과

- 중복 코드를 제거하고 계산 로직의 변경 범위를 줄일 수 있습니다.
- 코드의 명확성과 재사용성이 증가합니다.

### 절차

1. 임시 변수를 읽는 모든 코드를 질의 함수 호출로 변경합니다.
2. 질의 함수에서 임시 변수를 계산하도록 구현합니다.
3. 임시 변수를 제거합니다.

---

## 7.5 클래스 추출하기 (Extract Class)

### 목적

- 클래스가 너무 많은 책임을 가지는 경우, 일부 필드와 메서드를 새로운 클래스로 분리합니다.

### 효과

- 각 클래스의 책임을 명확히 하고, 코드의 응집도를 높입니다.
- 이해하기 쉬운 코드 구조를 만듭니다.

### 절차

1. 클래스에서 분리할 필드와 메서드를 식별합니다.
2. 새로운 클래스를 생성하여 식별된 요소를 이동합니다.
3. 기존 클래스에서 새로운 클래스를 사용하도록 참조를 추가합니다.

---

## 7.6 클래스 인라인하기 (Inline Class)

### 목적

- 클래스가 과도하게 추출되어 불필요하거나, 별도의 클래스로 분리할 필요가 없을 때 기존 클래스와 합칩니다.

### 효과

- 코드의 복잡성을 줄이고, 불필요한 클래스 계층 구조를 단순화합니다.

### 절차

1. 클래스를 사용하는 모든 코드를 호출하는 쪽으로 이동합니다.
2. 클래스를 제거합니다.

---

## 7.7 위임 숨기기 (Hide Delegate)

### 목적

- 외부 객체를 직접 사용하지 않고 중개 메서드를 통해 접근하도록 하여 의존성을 줄입니다.

### 효과

- 클라이언트 코드와 위임 객체 간의 결합도를 낮춥니다.
- 위임 객체의 변경이 클라이언트 코드에 미치는 영향을 줄일 수 있습니다.

### 절차

1. 위임 객체의 호출을 감싸는 메서드를 정의합니다.
2. 클라이언트가 직접 위임 객체를 호출하는 부분을 새 메서드로 대체합니다.

---

## 7.8 중개자 제거하기 (Remove Middle Man)

### 목적

- 중개자 메서드가 불필요한 경우, 클라이언트가 직접 호출하도록 변경하여 코드의 단순성을 높입니다.

### 효과

- 불필요한 간접 참조를 제거하여 성능과 가독성을 개선합니다.

### 절차

1. 중개자 메서드가 호출하는 실제 메서드로 클라이언트 호출을 변경합니다.
2. 더 이상 사용되지 않는 중개자 메서드를 제거합니다.

---

## 7.9 알고리즘 교체하기 (Replace Algorithm)

### 목적

- 기존 알고리즘이 비효율적이거나 이해하기 어려울 때 더 나은 알고리즘으로 교체합니다.

### 효과

- 성능을 개선하거나, 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.

### 절차

1. 새 알고리즘을 작성하고 테스트를 통해 검증합니다.
2. 기존 알고리즘 호출을 새 알고리즘 호출로 교체합니다.
3. 기존 알고리즘 코드를 제거합니다.

## 8.1 함수 옮기기 (Move Method)

### 목적

- 특정 클래스의 함수가 다른 클래스와 더 밀접한 관계가 있을 경우, 해당 클래스로 옮겨 응집도를 높임.

### 효과

- 데이터와 로직이 적절히 결합되어 유지보수성이 향상됨.
- 결합도가 감소하고 코드 구조가 더 직관적이 됨.

### 절차

1. 이동할 함수가 사용하는 데이터와 참조를 확인.
2. 대상 클래스에 새 함수를 작성하고 기존 로직을 복사.
3. 기존 함수를 새 함수 호출로 대체.
4. 호출하는 모든 코드를 새 함수로 업데이트.
5. 기존 함수를 삭제하고 테스트.

---

## 8.2 필드 옮기기 (Move Field)

### 목적

- 특정 클래스의 필드가 다른 클래스와 더 밀접한 관계가 있을 경우, 해당 클래스로 옮겨 응집도를 높임.

### 효과

- 데이터의 위치가 논리적으로 적절해지고 코드의 응집도가 향상됨.
- 결합도를 줄여 유지보수성을 높임.

### 절차

1. 새 필드를 대상 클래스에 추가.
2. 기존 필드의 참조를 새 클래스의 필드로 변경.
3. 기존 필드를 삭제하고 테스트.

---

## 8.3 문장을 함수로 옮기기 (Move Statements into Function)

### 목적

- 특정 코드 문장이 현재 함수보다 다른 함수와 더 관련성이 높을 때, 해당 함수로 이동.

### 효과

- 관련 로직이 응집되고, 중복이 줄어들며 가독성이 향상됨.

### 절차

1. 이동하려는 문장이 사용하는 데이터를 확인.
2. 대상 함수에 문장을 복사.
3. 기존 함수에서 문장을 삭제하고 새 함수 호출로 대체.
4. 변경 사항을 테스트.

---

## 8.4 문장을 호출한 곳으로 옮기기 (Move Statements to Caller)

### 목적

- 특정 코드 문장이 현재 함수보다 호출한 곳과 더 관련성이 있을 때, 호출한 곳으로 이동.

### 효과

- 호출한 곳에서 더 큰 컨텍스트를 제공하며 이해하기 쉬워짐.
- 함수의 책임을 명확히 분리.

### 절차

1. 이동하려는 문장을 호출한 곳으로 복사.
2. 기존 함수에서 문장을 제거.
3. 호출 코드에 맞게 수정하고 테스트.

---

## 8.5 인라인 코드를 함수 호출로 바꾸기 (Replace Inline Code with Function Call)

### 목적

- 중복된 코드를 제거하고, 공통 로직을 함수로 대체하여 가독성과 재사용성을 높임.

### 효과

- 코드가 간결하고 명확해짐.
- 동일한 로직을 수정할 때 한 곳만 변경하면 됨.

### 절차

1. 반복되거나 공통된 코드를 식별.
2. 공통된 로직을 함수로 추출.
3. 기존 코드를 함수 호출로 대체.
4. 테스트로 변경 사항 검증.

---

## 8.6 문장 슬라이스 하기 (Split Phase)

### 목적

- 하나의 함수가 여러 단계를 처리하는 경우, 각 단계를 별도의 함수로 분리하여 관리와 테스트를 용이하게 함.

### 효과

- 각 단계의 의미가 명확히 드러나며 가독성과 유지보수성이 향상됨.
- 각 단계가 독립적으로 테스트 가능.

### 절차

1. 단계별로 코드를 분석하여 분리 가능한 단계를 식별.
2. 각 단계를 별도 함수로 분리.
3. 기존 함수를 각 단계의 호출로 대체.
4. 전체 동작과 개별 단계를 테스트.

---

## 8.7 반복문 쪼개기 (Split Loop)

### 목적

- 하나의 반복문이 여러 작업을 수행할 경우, 각 작업을 별도의 반복문으로 분리.

### 효과

- 각 반복문의 목적이 명확히 드러나며 코드 이해가 쉬워짐.
- 반복문 내 로직 수정 시 영향 범위가 줄어듦.

### 절차

1. 반복문에서 수행하는 작업을 구분.
2. 각 작업을 별도의 반복문으로 이동.
3. 기존 반복문을 제거하고 테스트.

---

## 8.8 반복문을 파이프라인으로 바꾸기 (Replace Loop with Pipeline)

### 목적

- 반복문 대신 함수형 프로그래밍 스타일의 파이프라인(`map`, `filter`, `reduce`)을 사용하여 로직을 간결하게 표현.

### 효과

- 가독성과 유지보수성이 향상됨.
- 각 단계가 독립적으로 동작하여 로직의 이해가 쉬워짐.

### 절차

1. 반복문 내 처리 단계를 분석.
2. 각 단계를 적합한 파이프라인 함수로 변환.
3. 반복문을 제거하고 테스트.

---

## 8.9 죽은 코드 제거하기 (Remove Dead Code)

### 목적

- 더 이상 사용되지 않는 코드를 삭제하여 코드베이스를 간결하고 유지보수하기 쉽게 만듦.

### 효과

- 가독성과 유지보수성이 향상됨.
- 불필요한 코드로 인해 발생할 수 있는 혼란과 오류 제거.

### 절차

1. 사용되지 않는 코드를 분석하여 식별.
2. 외부에서 참조되지 않는지 확인.
3. 코드를 삭제하고 테스트.

---

**참고:** *리팩터링: 코드 구조를 개선하는 객체지향적 방법(2판)* 마틴 파울러(Martin Fowler) 저.


