# 리팩토링 기법 (Refactoring Techniques)
## 목차
1. [함수 추출하기 (Extract Method)](#함수-추출하기-extract-method)
2. [변수 인라인하기 (Inline Variable)](#변수-인라인하기-inline-variable)
3. [문장 슬라이스 하기 (Split Phase)](#문장-슬라이스-하기-split-phase)
4. [조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)](#조건부-로직을-다형성으로-바꾸기-replace-conditional-with-polymorphism)
5. [함수 옮기기 (Move Method)](#함수-옮기기-move-method)
6. [단계 쪼개기 (Split Phase)](#단계-쪼개기-split-phase)



1. **함수 추출하기 (Extract Method)**
    - **설명**: 코드의 특정 부분을 별도의 함수로 추출하여 코드의 가독성을 높이고 재사용성을 증가시키는 기법입니다.
    - **적용 이유**: 코드가 길어지고 복잡해질 때, 특정 기능을 수행하는 코드 블록을 새로운 함수로 만들어주면 더 이해하기 쉬워지고 테스트하기 용이합니다.
    - **예시**: 반복적으로 사용되는 로직을 독립적인 함수로 분리하여 코드의 중복을 줄이는 것.

2. **변수 인라인하기 (Inline Variable)**
    - **설명**: 의미가 없거나 코드의 가독성을 떨어뜨리는 임시 변수를 없애고, 그 값을 직접 사용하도록 바꾸는 기법입니다.
    - **적용 이유**: 변수가 코드 이해를 도와주는 역할을 하지 않거나 그저 값만 전달하는 경우, 해당 변수를 없애고 직관적으로 값 자체를 사용해 코드의 단순성을 높입니다.

3. **문장 슬라이스 하기 (Split Phase)**
    - **설명**: 하나의 함수나 메서드가 여러 단계의 작업을 수행할 때, 각 단계를 별도의 함수로 분리하는 기법입니다.
    - **적용 이유**: 각 단계를 별도로 관리하고 테스트할 수 있어 유지보수성이 향상되며, 단계마다 의미가 명확해져 가독성이 높아집니다.
    - **예시**: 데이터의 정제, 계산, 그리고 출력 작업을 각각 별도의 함수로 나누는 것.

4. **조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)**
    - **설명**: 조건문으로 구현된 로직을 다형성을 사용하여 각 조건에 따라 서로 다른 클래스를 만들어 처리하는 기법입니다.
    - **적용 이유**: 조건문이 많아지면 코드가 복잡해지고 읽기 어려워집니다. 이 문제를 다형성을 활용해 클래스 구조로 해결하면 각 클래스가 독립적으로 조건을 처리하게 되어 코드가 더 직관적이고 확장하기 쉬워집니다.
    - **예시**: `if-else` 또는 `switch` 문으로 작성된 수수료 계산 로직을 `FeeCalculator` 인터페이스와 이를 구현하는 여러 클래스로 대체하는 것.

5. **함수 옮기기 (Move Method)**
    - **설명**: 특정 클래스에 속해 있는 함수가 다른 클래스에서 더 잘 맞는 경우, 그 함수를 적절한 클래스나 모듈로 옮기는 기법입니다.
    - **적용 이유**: 데이터와 로직이 서로 잘 맞아야 코드가 더 직관적이고 유지보수하기 쉬워집니다. 함수가 적절하지 않은 클래스에 있을 경우, 이를 옮김으로써 응집도를 높이고 결합도를 낮출 수 있습니다.
    - **예시**: `calculateFee()` 함수가 `BankTransfer` 클래스보다는 각 수수료 계산 클래스에 있는 것이 더 적절한 경우, 해당 클래스로 옮기는 것.

6. **단계 쪼개기 (Split Phase)**
    - **설명**: 복잡한 처리를 단계별로 나누어 각각의 단계가 명확히 드러나도록 하는 기법입니다.
    - **적용 이유**: 여러 단계를 처리하는 코드가 있을 때 이를 명확히 분리하면 각 단계가 독립적이고 테스트하기 쉬워지며, 로직의 흐름을 쉽게 파악할 수 있습니다.
    - **예시**: `processTransfer()` 메서드에서 수수료 계산, 총 금액 계산, 그리고 출력 작업을 각각 별도의 함수로 나누어 각 작업을 명확히 드러나게 하는 것.

# 리팩토링 2판 요약

## 목차
1. [리팩토링 정의](#21-리팩토링-정의)
2. [두 개의 모자](#22-두-개의-모자)
3. [리팩토링 하는 이유](#23-리팩토링-하는-이유)
4. [언제 리팩토링을 해야 할까?](#24-언제-리팩토링을-해야-할까)
5. [리팩토링 시 고려할 문제](#25-리팩토링-시-고려할-문제)
6. [리팩토링, 아키텍처, 애그니](#26-리팩토링-아키텍처-애그니)
7. [리팩토링과 소프트웨어 개발 프로세스](#27-리팩토링과-소프트웨어-개발-프로세스)
8. [리팩토링과 성능](#28-리팩토링과-성능)
9. [리팩토링의 유래](#29-리팩토링의-유래)
10. [리팩토링 자동화](#210-리팩토링-자동화)

---

## 2.1 리팩토링 정의
- **정의**: 코드의 외부 동작은 유지하면서 내부 구조를 개선하는 과정.
- 리팩토링의 주요 목적:
   - **가독성**과 **유지보수성** 향상.
   - **코드 복잡도** 감소.
   - 새로운 기능 추가와 버그 수정을 더 쉽게 만듦.

---

## 2.2 두 개의 모자
- 개발자는 **기능 추가**와 **리팩토링**이라는 두 역할을 번갈아 수행해야 함.
- 기능 추가:
   - 새로운 요구사항에 맞게 코드를 작성.
- 리팩토링:
   - 코드 구조 개선에 집중.
- 역할을 분리하여 효율적인 작업과 높은 품질 유지.

---

## 2.3 리팩토링 하는 이유
- 시간이 지나면서 코드의 복잡도가 증가해 유지보수가 어려워짐.
- 리팩토링은 다음을 가능하게 함:
   - **팀 협업** 강화.
   - **기술 부채** 감소.
   - 새로운 기능 추가 및 변경 작업 용이.
   - **버그 수정**과 문제 해결이 쉬워짐.

---

## 2.4 언제 리팩토링을 해야 할까?
- 리팩토링이 필요한 신호들 (**Code Smells**):
   - 중복 코드, 긴 함수, 큰 클래스, 긴 매개변수 목록 등.
- 리팩토링의 적절한 시점:
   - **기능 추가 전**: 기존 코드를 개선하며 새로운 작업 준비.
   - **버그 수정 전**: 코드를 이해하고 문제 해결을 용이하게 함.
   - **코드 리뷰 후**: 피드백을 반영하며 개선.

---

## 2.5 리팩토링 시 고려할 문제
- **테스트 부족**: 기존 기능이 깨질 위험.
- **과도한 리팩토링**: 불필요한 리팩토링으로 생산성 저하.
- **팀의 공감 부족**: 리팩토링 필요성에 대한 팀원 간 이해 부족.
- 해결책:
   - 리팩토링 전후 **테스트 작성**으로 안정성 확보.
   - 팀 합의를 통해 계획적인 리팩토링 진행.

---

## 2.6 리팩토링, 아키텍처, 애그니
- 좋은 아키텍처는 리팩토링 필요성을 줄임.
- 리팩토링은 변화하는 요구사항에 맞춰 시스템의 **유연성**을 확보.
- **애그니(Agni)**:
   - 시스템의 복잡성을 해결하고 명확성을 높이는 데 기여.

---

## 2.7 리팩토링과 소프트웨어 개발 프로세스
- **애자일 개발**과 리팩토링:
   - 짧은 개발 주기 동안 지속적으로 코드 개선.
- **테스트 주도 개발(TDD)**:
   - 테스트 작성 후 리팩토링을 통해 안정적인 코드 작성.
- 지속적인 리팩토링은 소프트웨어의 **장기적인 성공**에 기여.

---

## 2.8 리팩토링과 성능
- 리팩토링은 성능 최적화를 목적으로 하지 않음.
- 코드 구조를 명확히 하여 성능 문제 해결을 쉽게 만듦.
- 성능 최적화는 리팩토링 이후 별도로 진행.

---

## 2.9 리팩토링의 유래
- 1990년대 초 **켄트 벡(Kent Beck)**과 **워드 커닝햄(Ward Cunningham)**이 개념 제안.
- **마틴 파울러(Martin Fowler)**가 이를 정리해 대중화.
- 현대 소프트웨어 개발의 필수적인 기법으로 자리 잡음.

---

## 2.10 리팩토링 자동화
- 현대 IDE(예: IntelliJ, Eclipse)에서 리팩토링 기능을 제공.
- 자동화 도구를 통해:
   - **시간 절약**.
   - **코드 안정성** 확보.
- 도구를 활용하여 리팩토링을 더 쉽게 수행 가능.


