# 리팩토링 기법 (Refactoring Techniques)
## 목차
1. [함수 추출하기 (Extract Method)](#함수-추출하기-extract-method)
2. [변수 인라인하기 (Inline Variable)](#변수-인라인하기-inline-variable)
3. [문장 슬라이스 하기 (Split Phase)](#문장-슬라이스-하기-split-phase)
4. [조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)](#조건부-로직을-다형성으로-바꾸기-replace-conditional-with-polymorphism)
5. [함수 옮기기 (Move Method)](#함수-옮기기-move-method)
6. [단계 쪼개기 (Split Phase)](#단계-쪼개기-split-phase)



1. **함수 추출하기 (Extract Method)**
    - **설명**: 코드의 특정 부분을 별도의 함수로 추출하여 코드의 가독성을 높이고 재사용성을 증가시키는 기법입니다.
    - **적용 이유**: 코드가 길어지고 복잡해질 때, 특정 기능을 수행하는 코드 블록을 새로운 함수로 만들어주면 더 이해하기 쉬워지고 테스트하기 용이합니다.
    - **예시**: 반복적으로 사용되는 로직을 독립적인 함수로 분리하여 코드의 중복을 줄이는 것.

2. **변수 인라인하기 (Inline Variable)**
    - **설명**: 의미가 없거나 코드의 가독성을 떨어뜨리는 임시 변수를 없애고, 그 값을 직접 사용하도록 바꾸는 기법입니다.
    - **적용 이유**: 변수가 코드 이해를 도와주는 역할을 하지 않거나 그저 값만 전달하는 경우, 해당 변수를 없애고 직관적으로 값 자체를 사용해 코드의 단순성을 높입니다.

3. **문장 슬라이스 하기 (Split Phase)**
    - **설명**: 하나의 함수나 메서드가 여러 단계의 작업을 수행할 때, 각 단계를 별도의 함수로 분리하는 기법입니다.
    - **적용 이유**: 각 단계를 별도로 관리하고 테스트할 수 있어 유지보수성이 향상되며, 단계마다 의미가 명확해져 가독성이 높아집니다.
    - **예시**: 데이터의 정제, 계산, 그리고 출력 작업을 각각 별도의 함수로 나누는 것.

4. **조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)**
    - **설명**: 조건문으로 구현된 로직을 다형성을 사용하여 각 조건에 따라 서로 다른 클래스를 만들어 처리하는 기법입니다.
    - **적용 이유**: 조건문이 많아지면 코드가 복잡해지고 읽기 어려워집니다. 이 문제를 다형성을 활용해 클래스 구조로 해결하면 각 클래스가 독립적으로 조건을 처리하게 되어 코드가 더 직관적이고 확장하기 쉬워집니다.
    - **예시**: `if-else` 또는 `switch` 문으로 작성된 수수료 계산 로직을 `FeeCalculator` 인터페이스와 이를 구현하는 여러 클래스로 대체하는 것.

5. **함수 옮기기 (Move Method)**
    - **설명**: 특정 클래스에 속해 있는 함수가 다른 클래스에서 더 잘 맞는 경우, 그 함수를 적절한 클래스나 모듈로 옮기는 기법입니다.
    - **적용 이유**: 데이터와 로직이 서로 잘 맞아야 코드가 더 직관적이고 유지보수하기 쉬워집니다. 함수가 적절하지 않은 클래스에 있을 경우, 이를 옮김으로써 응집도를 높이고 결합도를 낮출 수 있습니다.
    - **예시**: `calculateFee()` 함수가 `BankTransfer` 클래스보다는 각 수수료 계산 클래스에 있는 것이 더 적절한 경우, 해당 클래스로 옮기는 것.

6. **단계 쪼개기 (Split Phase)**
    - **설명**: 복잡한 처리를 단계별로 나누어 각각의 단계가 명확히 드러나도록 하는 기법입니다.
    - **적용 이유**: 여러 단계를 처리하는 코드가 있을 때 이를 명확히 분리하면 각 단계가 독립적이고 테스트하기 쉬워지며, 로직의 흐름을 쉽게 파악할 수 있습니다.
    - **예시**: `processTransfer()` 메서드에서 수수료 계산, 총 금액 계산, 그리고 출력 작업을 각각 별도의 함수로 나누어 각 작업을 명확히 드러나게 하는 것.

# 리팩토링 2판 요약

## 목차
1. [리팩토링 정의](#21-리팩토링-정의)
2. [두 개의 모자](#22-두-개의-모자)
3. [리팩토링 하는 이유](#23-리팩토링-하는-이유)
4. [언제 리팩토링을 해야 할까?](#24-언제-리팩토링을-해야-할까)
5. [리팩토링 시 고려할 문제](#25-리팩토링-시-고려할-문제)
6. [리팩토링, 아키텍처, 애그니](#26-리팩토링-아키텍처-애그니)
7. [리팩토링과 소프트웨어 개발 프로세스](#27-리팩토링과-소프트웨어-개발-프로세스)
8. [리팩토링과 성능](#28-리팩토링과-성능)
9. [리팩토링의 유래](#29-리팩토링의-유래)
10. [리팩토링 자동화](#210-리팩토링-자동화)

---

## 2.1 리팩토링 정의
- **정의**: 코드의 외부 동작은 유지하면서 내부 구조를 개선하는 과정.
- 리팩토링의 주요 목적:
   - **가독성**과 **유지보수성** 향상.
   - **코드 복잡도** 감소.
   - 새로운 기능 추가와 버그 수정을 더 쉽게 만듦.

---

## 2.2 두 개의 모자
- 개발자는 **기능 추가**와 **리팩토링**이라는 두 역할을 번갈아 수행해야 함.
- 기능 추가:
   - 새로운 요구사항에 맞게 코드를 작성.
- 리팩토링:
   - 코드 구조 개선에 집중.
- 역할을 분리하여 효율적인 작업과 높은 품질 유지.

---

## 2.3 리팩토링 하는 이유
- 시간이 지나면서 코드의 복잡도가 증가해 유지보수가 어려워짐.
- 리팩토링은 다음을 가능하게 함:
   - **팀 협업** 강화.
   - **기술 부채** 감소.
   - 새로운 기능 추가 및 변경 작업 용이.
   - **버그 수정**과 문제 해결이 쉬워짐.

---

## 2.4 언제 리팩토링을 해야 할까?
- 리팩토링이 필요한 신호들 (**Code Smells**):
   - 중복 코드, 긴 함수, 큰 클래스, 긴 매개변수 목록 등.
- 리팩토링의 적절한 시점:
   - **기능 추가 전**: 기존 코드를 개선하며 새로운 작업 준비.
   - **버그 수정 전**: 코드를 이해하고 문제 해결을 용이하게 함.
   - **코드 리뷰 후**: 피드백을 반영하며 개선.

---

## 2.5 리팩토링 시 고려할 문제
- **테스트 부족**: 기존 기능이 깨질 위험.
- **과도한 리팩토링**: 불필요한 리팩토링으로 생산성 저하.
- **팀의 공감 부족**: 리팩토링 필요성에 대한 팀원 간 이해 부족.
- 해결책:
   - 리팩토링 전후 **테스트 작성**으로 안정성 확보.
   - 팀 합의를 통해 계획적인 리팩토링 진행.

---

## 2.6 리팩토링, 아키텍처, 애그니
- 좋은 아키텍처는 리팩토링 필요성을 줄임.
- 리팩토링은 변화하는 요구사항에 맞춰 시스템의 **유연성**을 확보.
- **애그니(Agni)**:
   - 시스템의 복잡성을 해결하고 명확성을 높이는 데 기여.

---

## 2.7 리팩토링과 소프트웨어 개발 프로세스
- **애자일 개발**과 리팩토링:
   - 짧은 개발 주기 동안 지속적으로 코드 개선.
- **테스트 주도 개발(TDD)**:
   - 테스트 작성 후 리팩토링을 통해 안정적인 코드 작성.
- 지속적인 리팩토링은 소프트웨어의 **장기적인 성공**에 기여.

---

## 2.8 리팩토링과 성능
- 리팩토링은 성능 최적화를 목적으로 하지 않음.
- 코드 구조를 명확히 하여 성능 문제 해결을 쉽게 만듦.
- 성능 최적화는 리팩토링 이후 별도로 진행.

---

## 2.9 리팩토링의 유래
- 1990년대 초 **켄트 벡(Kent Beck)**과 **워드 커닝햄(Ward Cunningham)**이 개념 제안.
- **마틴 파울러(Martin Fowler)**가 이를 정리해 대중화.
- 현대 소프트웨어 개발의 필수적인 기법으로 자리 잡음.

---

## 2.10 리팩토링 자동화
- 현대 IDE(예: IntelliJ, Eclipse)에서 리팩토링 기능을 제공.
- 자동화 도구를 통해:
   - **시간 절약**.
   - **코드 안정성** 확보.
- 도구를 활용하여 리팩토링을 더 쉽게 수행 가능.

# 리팩토링 2판 3장: 코드에서 나는 악취

## 목차
1. [3.1 기이한 이름 (Mysterious Name)](#31-기이한-이름-mysterious-name)
2. [3.2 중복 코드 (Duplicated Code)](#32-중복-코드-duplicated-code)
3. [3.3 긴 함수 (Long Function)](#33-긴-함수-long-function)
4. [3.4 긴 매개변수 목록 (Long Parameter List)](#34-긴-매개변수-목록-long-parameter-list)
5. [3.5 전역 데이터 (Global Data)](#35-전역-데이터-global-data)
6. [3.6 가변 데이터 (Mutable Data)](#36-가변-데이터-mutable-data)
7. [3.7 뒤엉킨 변경 (Divergent Change)](#37-뒤엉킨-변경-divergent-change)
8. [3.8 산탄총 수술 (Shotgun Surgery)](#38-산탄총-수술-shotgun-surgery)
9. [3.9 기능 편애 (Feature Envy)](#39-기능-편애-feature-envy)
10. [3.10 데이터 뭉치 (Data Clumps)](#310-데이터-뭉치-data-clumps)
11. [3.11 기본형 집착 (Primitive Obsession)](#311-기본형-집착-primitive-obsession)
12. [3.12 반복되는 switch문 (Repeated Switch Statements)](#312-반복되는-switch문-repeated-switch-statements)
13. [3.13 반복문 (Loops)](#313-반복문-loops)
14. [3.14 성의없는 요소 (Lazy Element)](#314-성의없는-요소-lazy-element)
15. [3.15 추측성 일반화 (Speculative Generality)](#315-추측성-일반화-speculative-generality)
16. [3.16 임시 필드 (Temporary Field)](#316-임시-필드-temporary-field)
17. [3.17 메시지 체인 (Message Chains)](#317-메시지-체인-message-chains)
18. [3.18 중개자 (Middle Man)](#318-중개자-middle-man)
19. [3.19 내부자 거래 (Insider Trading)](#319-내부자-거래-insider-trading)
20. [3.20 거대한 클래스 (Large Class)](#320-거대한-클래스-large-class)
21. [3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)](#321-서로-다른-인터페이스의-대안-클래스들-alternative-classes-with-different-interfaces)
22. [3.22 데이터 클래스 (Data Class)](#322-데이터-클래스-data-class)
23. [3.23 상속 포기 (Refused Bequest)](#323-상속-포기-refused-bequest)
24. [3.24 주석 (Comments)](#324-주석-comments)

리팩토링 2판 3장에서는 코드에서 흔히 발생하는 문제점들, 즉 '악취'에 대해 설명합니다. 이 악취들은 코드 품질을 떨어뜨리고 유지보수를 어렵게 만듭니다. 아래는 각 악취에 대한 간략한 설명입니다.

## 3.1 기이한 이름 (Mysterious Name)
이름이 모호하거나 의도가 명확하지 않은 경우입니다. 함수나 변수의 이름은 그 목적을 분명히 나타내야 합니다.

## 3.2 중복 코드 (Duplicated Code)
여러 곳에서 동일한 코드가 반복될 때 발생합니다. 중복 코드를 제거하여 유지보수를 쉽게 만듭니다.

## 3.3 긴 함수 (Long Function)
함수가 너무 길어서 이해하기 어렵습니다. 각 기능을 별도의 함수로 분리하여 가독성을 높입니다.

## 3.4 긴 매개변수 목록 (Long Parameter List)
함수의 매개변수가 너무 많아서 이해하기 어렵습니다. 관련 매개변수들을 객체로 묶어 단순화합니다.

## 3.5 전역 데이터 (Global Data)
전역 변수를 사용하면 데이터의 의도를 파악하기 어렵고, 부작용이 생기기 쉽습니다. 데이터를 캡슐화하여 부작용을 최소화합니다.

## 3.6 가변 데이터 (Mutable Data)
데이터가 쉽게 변경될 수 있으면 추적이 어렵습니다. 변경 가능성을 줄이고, 불변성을 유지하는 것이 좋습니다.

## 3.7 뒤엉킨 변경 (Divergent Change)
하나의 클래스가 여러 가지 이유로 변경되는 경우입니다. 단일 책임 원칙(SRP)을 준수하여 각 클래스가 하나의 변경 이유만 가지도록 합니다.

## 3.8 산탄총 수술 (Shotgun Surgery)
하나의 변경이 여러 클래스에 영향을 미치는 경우입니다. 관련된 기능을 한 곳으로 모아 변경 범위를 줄입니다.

## 3.9 기능 편애 (Feature Envy)
한 클래스가 다른 클래스의 데이터에 지나치게 의존하는 경우입니다. 데이터를 소유한 클래스가 그 데이터를 처리하도록 만듭니다.

## 3.10 데이터 뭉치 (Data Clumps)
항상 함께 사용되는 데이터가 따로 존재하는 경우입니다. 관련 데이터를 객체로 묶어줍니다.

## 3.11 기본형 집착 (Primitive Obsession)
기본 데이터 타입만을 고집하여 도메인 개념을 표현하지 못하는 경우입니다. 의미 있는 객체로 변경하여 도메인 개념을 명확히 합니다.

## 3.12 반복되는 switch문 (Repeated Switch Statements)
같은 조건문이 반복될 때 발생합니다. 다형성을 활용하여 조건문을 없애거나 줄입니다.

## 3.13 반복문 (Loops)
반복문을 함수형 프로그래밍 패턴으로 바꾸는 것이 좋습니다. 스트림과 같은 고수준 추상화를 사용하여 가독성을 높입니다.

## 3.14 성의없는 요소 (Lazy Element)
클래스나 메서드가 충분히 의미를 가지지 못하는 경우입니다. 필요하지 않은 클래스나 메서드는 제거합니다.

## 3.15 추측성 일반화 (Speculative Generality)
필요하지 않은 일반화가 이루어지는 경우입니다. 필요할 때까진 간단한 구현만 유지합니다.

## 3.16 임시 필드 (Temporary Field)
필드가 특정 상황에서만 값이 있는 경우입니다. 필요할 때만 사용하는 필드는 메서드로 국한시킵니다.

## 3.17 메시지 체인 (Message Chains)
여러 객체를 연속으로 호출하는 경우입니다. 호출을 캡슐화하여 메시지 체인을 줄입니다.

## 3.18 중개자 (Middle Man)
불필요하게 다른 클래스의 기능을 감싸기만 하는 경우입니다. 불필요한 중개자는 제거합니다.

## 3.19 내부자 거래 (Insider Trading)
두 클래스가 서로의 내부 정보를 지나치게 공유하는 경우입니다. 캡슐화를 통해 내부 정보의 접근을 최소화합니다.

## 3.20 거대한 클래스 (Large Class)
너무 많은 책임을 가진 클래스입니다. 클래스를 분할하여 각 클래스가 단일 책임을 가지도록 합니다.

## 3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)
비슷한 역할을 하는데 인터페이스가 다른 클래스들이 존재하는 경우입니다. 공통 인터페이스를 정의하여 일관성을 유지합니다.

## 3.22 데이터 클래스 (Data Class)
데이터만 저장하고 기능이 없는 클래스입니다. 해당 클래스에서 관련 동작을 추가하여 행동을 부여합니다.

## 3.23 상속 포기 (Refused Bequest)
상속받은 클래스가 부모 클래스의 기능을 사용하지 않는 경우입니다. 상속 대신 컴포지션을 고려합니다.

## 3.24 주석 (Comments)
코드를 보충 설명하는 주석이 많다면, 그만큼 코드가 읽기 어렵다는 신호일 수 있습니다. 코드 자체를 명확하게 작성하여 주석의 필요성을 줄입니다.





