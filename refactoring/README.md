# 리팩토링 기법 (Refactoring Techniques)
## 목차
1. [함수 추출하기 (Extract Method)](#함수-추출하기-extract-method)
2. [변수 인라인하기 (Inline Variable)](#변수-인라인하기-inline-variable)
3. [문장 슬라이스 하기 (Split Phase)](#문장-슬라이스-하기-split-phase)
4. [조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)](#조건부-로직을-다형성으로-바꾸기-replace-conditional-with-polymorphism)
5. [함수 옮기기 (Move Method)](#함수-옮기기-move-method)
6. [단계 쪼개기 (Split Phase)](#단계-쪼개기-split-phase)



1. **함수 추출하기 (Extract Method)**
    - **설명**: 코드의 특정 부분을 별도의 함수로 추출하여 코드의 가독성을 높이고 재사용성을 증가시키는 기법입니다.
    - **적용 이유**: 코드가 길어지고 복잡해질 때, 특정 기능을 수행하는 코드 블록을 새로운 함수로 만들어주면 더 이해하기 쉬워지고 테스트하기 용이합니다.
    - **예시**: 반복적으로 사용되는 로직을 독립적인 함수로 분리하여 코드의 중복을 줄이는 것.

2. **변수 인라인하기 (Inline Variable)**
    - **설명**: 의미가 없거나 코드의 가독성을 떨어뜨리는 임시 변수를 없애고, 그 값을 직접 사용하도록 바꾸는 기법입니다.
    - **적용 이유**: 변수가 코드 이해를 도와주는 역할을 하지 않거나 그저 값만 전달하는 경우, 해당 변수를 없애고 직관적으로 값 자체를 사용해 코드의 단순성을 높입니다.

3. **문장 슬라이스 하기 (Split Phase)**
    - **설명**: 하나의 함수나 메서드가 여러 단계의 작업을 수행할 때, 각 단계를 별도의 함수로 분리하는 기법입니다.
    - **적용 이유**: 각 단계를 별도로 관리하고 테스트할 수 있어 유지보수성이 향상되며, 단계마다 의미가 명확해져 가독성이 높아집니다.
    - **예시**: 데이터의 정제, 계산, 그리고 출력 작업을 각각 별도의 함수로 나누는 것.

4. **조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)**
    - **설명**: 조건문으로 구현된 로직을 다형성을 사용하여 각 조건에 따라 서로 다른 클래스를 만들어 처리하는 기법입니다.
    - **적용 이유**: 조건문이 많아지면 코드가 복잡해지고 읽기 어려워집니다. 이 문제를 다형성을 활용해 클래스 구조로 해결하면 각 클래스가 독립적으로 조건을 처리하게 되어 코드가 더 직관적이고 확장하기 쉬워집니다.
    - **예시**: `if-else` 또는 `switch` 문으로 작성된 수수료 계산 로직을 `FeeCalculator` 인터페이스와 이를 구현하는 여러 클래스로 대체하는 것.

5. **함수 옮기기 (Move Method)**
    - **설명**: 특정 클래스에 속해 있는 함수가 다른 클래스에서 더 잘 맞는 경우, 그 함수를 적절한 클래스나 모듈로 옮기는 기법입니다.
    - **적용 이유**: 데이터와 로직이 서로 잘 맞아야 코드가 더 직관적이고 유지보수하기 쉬워집니다. 함수가 적절하지 않은 클래스에 있을 경우, 이를 옮김으로써 응집도를 높이고 결합도를 낮출 수 있습니다.
    - **예시**: `calculateFee()` 함수가 `BankTransfer` 클래스보다는 각 수수료 계산 클래스에 있는 것이 더 적절한 경우, 해당 클래스로 옮기는 것.

6. **단계 쪼개기 (Split Phase)**
    - **설명**: 복잡한 처리를 단계별로 나누어 각각의 단계가 명확히 드러나도록 하는 기법입니다.
    - **적용 이유**: 여러 단계를 처리하는 코드가 있을 때 이를 명확히 분리하면 각 단계가 독립적이고 테스트하기 쉬워지며, 로직의 흐름을 쉽게 파악할 수 있습니다.
    - **예시**: `processTransfer()` 메서드에서 수수료 계산, 총 금액 계산, 그리고 출력 작업을 각각 별도의 함수로 나누어 각 작업을 명확히 드러나게 하는 것.

# 리팩토링 2판 요약

## 목차
1. [리팩토링 정의](#21-리팩토링-정의)
2. [두 개의 모자](#22-두-개의-모자)
3. [리팩토링 하는 이유](#23-리팩토링-하는-이유)
4. [언제 리팩토링을 해야 할까?](#24-언제-리팩토링을-해야-할까)
5. [리팩토링 시 고려할 문제](#25-리팩토링-시-고려할-문제)
6. [리팩토링, 아키텍처, 애그니](#26-리팩토링-아키텍처-애그니)
7. [리팩토링과 소프트웨어 개발 프로세스](#27-리팩토링과-소프트웨어-개발-프로세스)
8. [리팩토링과 성능](#28-리팩토링과-성능)
9. [리팩토링의 유래](#29-리팩토링의-유래)
10. [리팩토링 자동화](#210-리팩토링-자동화)

---

## 2.1 리팩토링 정의
- **정의**: 코드의 외부 동작은 유지하면서 내부 구조를 개선하는 과정.
- 리팩토링의 주요 목적:
   - **가독성**과 **유지보수성** 향상.
   - **코드 복잡도** 감소.
   - 새로운 기능 추가와 버그 수정을 더 쉽게 만듦.

---

## 2.2 두 개의 모자
- 개발자는 **기능 추가**와 **리팩토링**이라는 두 역할을 번갈아 수행해야 함.
- 기능 추가:
   - 새로운 요구사항에 맞게 코드를 작성.
- 리팩토링:
   - 코드 구조 개선에 집중.
- 역할을 분리하여 효율적인 작업과 높은 품질 유지.

---

## 2.3 리팩토링 하는 이유
- 시간이 지나면서 코드의 복잡도가 증가해 유지보수가 어려워짐.
- 리팩토링은 다음을 가능하게 함:
   - **팀 협업** 강화.
   - **기술 부채** 감소.
   - 새로운 기능 추가 및 변경 작업 용이.
   - **버그 수정**과 문제 해결이 쉬워짐.

---

## 2.4 언제 리팩토링을 해야 할까?
- 리팩토링이 필요한 신호들 (**Code Smells**):
   - 중복 코드, 긴 함수, 큰 클래스, 긴 매개변수 목록 등.
- 리팩토링의 적절한 시점:
   - **기능 추가 전**: 기존 코드를 개선하며 새로운 작업 준비.
   - **버그 수정 전**: 코드를 이해하고 문제 해결을 용이하게 함.
   - **코드 리뷰 후**: 피드백을 반영하며 개선.

---

## 2.5 리팩토링 시 고려할 문제
- **테스트 부족**: 기존 기능이 깨질 위험.
- **과도한 리팩토링**: 불필요한 리팩토링으로 생산성 저하.
- **팀의 공감 부족**: 리팩토링 필요성에 대한 팀원 간 이해 부족.
- 해결책:
   - 리팩토링 전후 **테스트 작성**으로 안정성 확보.
   - 팀 합의를 통해 계획적인 리팩토링 진행.

---

## 2.6 리팩토링, 아키텍처, 애그니
- 좋은 아키텍처는 리팩토링 필요성을 줄임.
- 리팩토링은 변화하는 요구사항에 맞춰 시스템의 **유연성**을 확보.
- **애그니(Agni)**:
   - 시스템의 복잡성을 해결하고 명확성을 높이는 데 기여.

---

## 2.7 리팩토링과 소프트웨어 개발 프로세스
- **애자일 개발**과 리팩토링:
   - 짧은 개발 주기 동안 지속적으로 코드 개선.
- **테스트 주도 개발(TDD)**:
   - 테스트 작성 후 리팩토링을 통해 안정적인 코드 작성.
- 지속적인 리팩토링은 소프트웨어의 **장기적인 성공**에 기여.

---

## 2.8 리팩토링과 성능
- 리팩토링은 성능 최적화를 목적으로 하지 않음.
- 코드 구조를 명확히 하여 성능 문제 해결을 쉽게 만듦.
- 성능 최적화는 리팩토링 이후 별도로 진행.

---

## 2.9 리팩토링의 유래
- 1990년대 초 **켄트 벡(Kent Beck)**과 **워드 커닝햄(Ward Cunningham)**이 개념 제안.
- **마틴 파울러(Martin Fowler)**가 이를 정리해 대중화.
- 현대 소프트웨어 개발의 필수적인 기법으로 자리 잡음.

---

## 2.10 리팩토링 자동화
- 현대 IDE(예: IntelliJ, Eclipse)에서 리팩토링 기능을 제공.
- 자동화 도구를 통해:
   - **시간 절약**.
   - **코드 안정성** 확보.
- 도구를 활용하여 리팩토링을 더 쉽게 수행 가능.

# 리팩토링 2판 3장: 코드에서 나는 악취

## 목차
1. [3.1 기이한 이름 (Mysterious Name)](#31-기이한-이름-mysterious-name)
2. [3.2 중복 코드 (Duplicated Code)](#32-중복-코드-duplicated-code)
3. [3.3 긴 함수 (Long Function)](#33-긴-함수-long-function)
4. [3.4 긴 매개변수 목록 (Long Parameter List)](#34-긴-매개변수-목록-long-parameter-list)
5. [3.5 전역 데이터 (Global Data)](#35-전역-데이터-global-data)
6. [3.6 가변 데이터 (Mutable Data)](#36-가변-데이터-mutable-data)
7. [3.7 뒤엉킨 변경 (Divergent Change)](#37-뒤엉킨-변경-divergent-change)
8. [3.8 산탄총 수술 (Shotgun Surgery)](#38-산탄총-수술-shotgun-surgery)
9. [3.9 기능 편애 (Feature Envy)](#39-기능-편애-feature-envy)
10. [3.10 데이터 뭉치 (Data Clumps)](#310-데이터-뭉치-data-clumps)
11. [3.11 기본형 집착 (Primitive Obsession)](#311-기본형-집착-primitive-obsession)
12. [3.12 반복되는 switch문 (Repeated Switch Statements)](#312-반복되는-switch문-repeated-switch-statements)
13. [3.13 반복문 (Loops)](#313-반복문-loops)
14. [3.14 성의없는 요소 (Lazy Element)](#314-성의없는-요소-lazy-element)
15. [3.15 추측성 일반화 (Speculative Generality)](#315-추측성-일반화-speculative-generality)
16. [3.16 임시 필드 (Temporary Field)](#316-임시-필드-temporary-field)
17. [3.17 메시지 체인 (Message Chains)](#317-메시지-체인-message-chains)
18. [3.18 중개자 (Middle Man)](#318-중개자-middle-man)
19. [3.19 내부자 거래 (Insider Trading)](#319-내부자-거래-insider-trading)
20. [3.20 거대한 클래스 (Large Class)](#320-거대한-클래스-large-class)
21. [3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)](#321-서로-다른-인터페이스의-대안-클래스들-alternative-classes-with-different-interfaces)
22. [3.22 데이터 클래스 (Data Class)](#322-데이터-클래스-data-class)
23. [3.23 상속 포기 (Refused Bequest)](#323-상속-포기-refused-bequest)
24. [3.24 주석 (Comments)](#324-주석-comments)

리팩토링 2판 3장에서는 코드에서 흔히 발생하는 문제점들, 즉 '악취'에 대해 설명합니다. 이 악취들은 코드 품질을 떨어뜨리고 유지보수를 어렵게 만듭니다. 아래는 각 악취에 대한 간략한 설명입니다.

## 3.1 기이한 이름 (Mysterious Name)
이름이 모호하거나 의도가 명확하지 않은 경우입니다. 함수나 변수의 이름은 그 목적을 분명히 나타내야 합니다.

## 3.2 중복 코드 (Duplicated Code)
여러 곳에서 동일한 코드가 반복될 때 발생합니다. 중복 코드를 제거하여 유지보수를 쉽게 만듭니다.

## 3.3 긴 함수 (Long Function)
함수가 너무 길어서 이해하기 어렵습니다. 각 기능을 별도의 함수로 분리하여 가독성을 높입니다.

## 3.4 긴 매개변수 목록 (Long Parameter List)
함수의 매개변수가 너무 많아서 이해하기 어렵습니다. 관련 매개변수들을 객체로 묶어 단순화합니다.

## 3.5 전역 데이터 (Global Data)
전역 변수를 사용하면 데이터의 의도를 파악하기 어렵고, 부작용이 생기기 쉽습니다. 데이터를 캡슐화하여 부작용을 최소화합니다.

## 3.6 가변 데이터 (Mutable Data)
데이터가 쉽게 변경될 수 있으면 추적이 어렵습니다. 변경 가능성을 줄이고, 불변성을 유지하는 것이 좋습니다.

## 3.7 뒤엉킨 변경 (Divergent Change)
하나의 클래스가 여러 가지 이유로 변경되는 경우입니다. 단일 책임 원칙(SRP)을 준수하여 각 클래스가 하나의 변경 이유만 가지도록 합니다.

## 3.8 산탄총 수술 (Shotgun Surgery)
하나의 변경이 여러 클래스에 영향을 미치는 경우입니다. 관련된 기능을 한 곳으로 모아 변경 범위를 줄입니다.

## 3.9 기능 편애 (Feature Envy)
한 클래스가 다른 클래스의 데이터에 지나치게 의존하는 경우입니다. 데이터를 소유한 클래스가 그 데이터를 처리하도록 만듭니다.

## 3.10 데이터 뭉치 (Data Clumps)
항상 함께 사용되는 데이터가 따로 존재하는 경우입니다. 관련 데이터를 객체로 묶어줍니다.

## 3.11 기본형 집착 (Primitive Obsession)
기본 데이터 타입만을 고집하여 도메인 개념을 표현하지 못하는 경우입니다. 의미 있는 객체로 변경하여 도메인 개념을 명확히 합니다.

## 3.12 반복되는 switch문 (Repeated Switch Statements)
같은 조건문이 반복될 때 발생합니다. 다형성을 활용하여 조건문을 없애거나 줄입니다.

## 3.13 반복문 (Loops)
반복문을 함수형 프로그래밍 패턴으로 바꾸는 것이 좋습니다. 스트림과 같은 고수준 추상화를 사용하여 가독성을 높입니다.

## 3.14 성의없는 요소 (Lazy Element)
클래스나 메서드가 충분히 의미를 가지지 못하는 경우입니다. 필요하지 않은 클래스나 메서드는 제거합니다.

## 3.15 추측성 일반화 (Speculative Generality)
필요하지 않은 일반화가 이루어지는 경우입니다. 필요할 때까진 간단한 구현만 유지합니다.

## 3.16 임시 필드 (Temporary Field)
필드가 특정 상황에서만 값이 있는 경우입니다. 필요할 때만 사용하는 필드는 메서드로 국한시킵니다.

## 3.17 메시지 체인 (Message Chains)
여러 객체를 연속으로 호출하는 경우입니다. 호출을 캡슐화하여 메시지 체인을 줄입니다.

## 3.18 중개자 (Middle Man)
불필요하게 다른 클래스의 기능을 감싸기만 하는 경우입니다. 불필요한 중개자는 제거합니다.

## 3.19 내부자 거래 (Insider Trading)
두 클래스가 서로의 내부 정보를 지나치게 공유하는 경우입니다. 캡슐화를 통해 내부 정보의 접근을 최소화합니다.

## 3.20 거대한 클래스 (Large Class)
너무 많은 책임을 가진 클래스입니다. 클래스를 분할하여 각 클래스가 단일 책임을 가지도록 합니다.

## 3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)
비슷한 역할을 하는데 인터페이스가 다른 클래스들이 존재하는 경우입니다. 공통 인터페이스를 정의하여 일관성을 유지합니다.

## 3.22 데이터 클래스 (Data Class)
데이터만 저장하고 기능이 없는 클래스입니다. 해당 클래스에서 관련 동작을 추가하여 행동을 부여합니다.

## 3.23 상속 포기 (Refused Bequest)
상속받은 클래스가 부모 클래스의 기능을 사용하지 않는 경우입니다. 상속 대신 컴포지션을 고려합니다.

## 3.24 주석 (Comments)
코드를 보충 설명하는 주석이 많다면, 그만큼 코드가 읽기 어렵다는 신호일 수 있습니다. 코드 자체를 명확하게 작성하여 주석의 필요성을 줄입니다.



# 리팩토링 4장 요약: 테스트를 통한 코드 개선

## 4.1 자가 테스트 코드의 가치
- **자가 테스트 코드**는 리팩토링의 필수적인 부분입니다. 코드가 변할 때 문제가 발생하지 않음을 보장하는 유일한 수단입니다.
- 테스트는 **안전망** 역할을 하여, 기존의 동작을 유지하면서 코드를 개선할 수 있도록 합니다.
- 리팩토링 시 안정적인 변화를 위해서는 자가 테스트 코드가 필요하며, 이는 코드의 품질과 유지보수성을 높이는 중요한 요소입니다.

## 4.2 테스트할 샘플 코드
- **테스트할 샘플 코드**로는 자바스크립트의 청구서 계산 예시가 제시됩니다.
- 단일 함수로 작성된 코드가 복잡하고 긴 형태로 되어 있어, 이 코드의 이해와 유지보수가 어렵습니다.
- 이를 테스트와 리팩토링을 통해 더 읽기 쉽고 효율적인 코드로 개선할 것입니다.

## 4.3 첫 번째 테스트
- 코드 리팩토링을 시작하기 전에 가장 중요한 것은 **기본적인 테스트를 작성**하는 것입니다.
- 청구서 계산 기능에 대해 첫 번째 테스트 케이스를 작성하고, 이를 통해 현재 코드의 정상 동작을 검증합니다.
- 테스트는 코드의 **의도와 기대 결과**를 명확히 하고, 리팩토링 중 오류 발생 시 빠르게 확인할 수 있게 해줍니다.

## 4.4 테스트 추가하기
- 첫 번째 테스트 이후, 다양한 경우를 대비해 **추가적인 테스트 케이스**를 작성합니다.
- 다른 청구서 데이터에 대한 테스트를 추가해 코드가 여러 시나리오에서 안정적으로 동작하는지 확인합니다.
- 이 과정에서 잠재적인 **엣지 케이스**를 발견하고, 이에 대한 처리를 테스트로 보강합니다.

## 4.5 픽스처 수정하기
- **픽스처(fixture)**는 테스트에서 반복적으로 사용되는 데이터를 의미합니다.
- 테스트를 추가하고 픽스처를 정리하며, 중복된 설정을 줄이고 **테스트 코드의 재사용성**을 높입니다.
- 픽스처를 수정하면서 테스트 코드가 보다 **간결**해지고, 변경에 용이해집니다.

## 4.6 경계 조건 검사하기
- 테스트할 때 **경계 조건**을 반드시 고려해야 합니다.
- 예를 들어, 데이터가 없을 때, 최대 또는 최소값일 때 등의 경계 상황에 대해 테스트를 작성하여 코드의 강건성을 확보합니다.
- 경계 조건을 충분히 다루는 테스트는 리팩토링 시 발생할 수 있는 예상치 못한 문제를 줄여줍니다.

## 4.7 끝나지 않은 여정
- 테스트는 일회성 작업이 아닌 **계속되는 여정**입니다.
- 리팩토링 과정에서 테스트는 코드 변경에 대한 신뢰를 제공합니다.
- 더 나은 코드를 위해 지속적으로 테스트를 추가하고 개선해 나가는 것이 중요합니다.

## 결론
- **자가 테스트 코드**는 리팩토링의 안전망으로, 코드의 품질과 안정성을 보장합니다.
- 첫 번째 테스트에서 경계 조건까지 점진적으로 테스트를 추가하며, 코드를 리팩토링하고 개선해 나갑니다.
- 테스트는 코드 리팩토링의 끝나지 않은 여정이며, 더 나은 코드와 시스템을 위해 지속적으로 관리하고 확장해 나가야 합니다.

# Automated Testing Guidelines

자동화 테스트는 소프트웨어 개발에서 중요한 역할을 하며, 코드의 안정성과 신뢰성을 보장합니다. 아래는 강력하고 효과적인 테스트 스위트를 구축하기 위한 기본 원칙들을 설명합니다.

## 1. 모든 테스트를 완전히 자동화하고 결과를 자동으로 검사하기

자동화된 테스트는 수동 확인 없이 모든 테스트를 실행하고 결과를 검증합니다. 이를 통해 개발자는 코드 변경 시 기존 기능의 문제가 발생하는 것을 예방할 수 있습니다. 자동화 테스트는 신뢰성 있는 코드베이스를 유지하는 중요한 도구입니다.

## 2. 테스트 스위트는 강력한 버그 검출 도구

테스트 스위트는 미리 정의된 다양한 시나리오를 자동으로 실행하여 버그를 찾는 도구입니다. 테스트 스위트를 잘 구성하면 수동 디버깅에 드는 시간을 크게 줄일 수 있으며, 개발 속도와 안정성을 동시에 높일 수 있습니다.

## 3. 실패해야 할 상황에는 반드시 실패하게 만들기

특정 상황에서 코드가 올바르게 동작하지 않는지를 검증하는 테스트가 필요합니다. 잘못된 입력에 대해 시스템이 정상적으로 에러를 반환하는지 확인하는 것은 필수적입니다. 테스트가 실패해야 할 상황을 명확히 정의하여 시스템의 신뢰성을 강화하세요.

## 4. 자주 테스트하기

작성 중인 코드는 최소한 몇 분 간격으로 테스트하고, 하루에 적어도 한 번은 전체 테스트를 실행하세요. 잦은 테스트는 빠른 피드백을 제공하여 문제를 조기에 발견하고 수정하는 데 도움을 줍니다. 지속적인 통합(Continuous Integration) 환경에서는 커밋마다 자동으로 테스트를 실행하는 것이 일반적입니다.

## 5. 완벽하지 않은 테스트라도 실행하기

완벽한 테스트를 작성하기 위해 지나치게 시간을 들이느니, 불완전하더라도 기본적인 테스트를 작성하고 실행하는 것이 낫습니다. 모든 경우의 수를 완벽히 검증하지 못하더라도 주요 기능과 흐름을 테스트하는 것만으로도 많은 문제를 예방할 수 있습니다.

## 6. 경계 조건 집중 테스트

경계 조건은 시스템의 특정 경계에 있는 값들을 말합니다. 예를 들어 최대값, 최소값 또는 그 근처의 값들이 이에 해당됩니다. 이러한 경계 조건을 철저히 테스트하면 많은 잠재적인 버그를 예방할 수 있습니다. 특히, 입력값의 범위나 배열의 끝 값을 처리하는 로직에서는 경계 조건 테스트가 필수적입니다.

## 7. 모든 버그를 잡아낼 수 없다고 테스트를 포기하지 말기

모든 버그를 완벽히 잡는 것은 어렵지만, 테스트를 포기한다면 많은 중요한 버그를 놓칠 수 있습니다. 테스트를 통해 최대한 많은 문제를 사전에 해결하는 것이 중요합니다. 테스트는 대다수의 문제를 미리 잡아낼 수 있는 기회를 제공하며, 이를 통해 사용자에게 발생할 수 있는 심각한 결함을 예방할 수 있습니다.

## 결론

자동화된 테스트는 코드의 품질을 유지하고, 변경 사항에 대한 빠른 피드백을 제공하며, 버그를 사전에 방지할 수 있는 중요한 도구입니다. 개발자는 테스트를 통해 더욱 안전하고 유지보수하기 쉬운 소프트웨어를 구축할 수 있습니다. 따라서 테스트를 자동화하고, 자주 실행하며, 경계 조건에 대한 테스트를 강화하는 습관을 갖는 것이 중요합니다.

더 나은 소프트웨어 개발을 위해 테스트의 중요성을 잊지 말고, 언제나 **자주, 꾸준히, 철저히** 테스트하세요.


# 리팩토링 6장: 기본적인 리팩터링

이 문서는 *리팩터링: 코드 구조를 개선하는 객체지향적 방법(2판)* 6장에서 다룬 주요 내용을 요약한 것입니다.

## 6.1 함수 추출하기
**목적:** 복잡한 함수를 더 작고 의미 있는 함수로 나누기.

- 논리적으로 묶을 수 있는 코드 블록을 식별합니다.
- 새 함수를 생성하고 해당 코드 블록을 이동시킵니다.
- 원래 코드 블록을 새 함수 호출로 대체합니다.
- **효과:** 코드 가독성과 재사용성을 향상시킵니다.

---

## 6.2 함수 인라인하기
**목적:** 불필요한 간접 참조를 제거하여 코드를 단순화하기.

- 함수 호출을 함수의 본문으로 대체합니다.
- 함수가 너무 짧거나 더 이상 필요하지 않을 때 유용합니다.
- **효과:** 복잡성을 줄이고 코드의 명확성을 높입니다.

---

## 6.3 변수 추출하기
**목적:** 표현식을 변수로 추출하여 코드 이해도를 높이기.

- 복잡하거나 반복되는 표현식을 식별합니다.
- 표현식 결과를 새 변수에 할당합니다.
- 원래 표현식을 해당 변수로 대체합니다.
- **효과:** 코드 가독성을 개선합니다.

---

## 6.4 변수 인라인하기
**목적:** 명확성을 더하지 않는 변수를 제거하여 코드를 단순화하기.

- 변수의 값이 그대로 코드에 삽입되어도 이해가 가능하다면 변수를 제거합니다.
- **효과:** 불필요한 간접 참조를 줄입니다.

---

## 6.5 함수 이름 바꾸기
**목적:** 함수에 의미 있는 이름을 부여하여 코드 이해도를 높이기.

- 함수의 목적을 더 잘 설명할 수 있는 이름으로 변경합니다.
- 모든 참조를 새로운 함수 이름으로 업데이트합니다.
- **효과:** 코드베이스를 탐색하고 유지보수하기 쉬워집니다.

---

## 6.6 변수 캡슐화하기
**목적:** 변수의 직접 접근을 제한하고 접근 제어를 강화하기.

- 변수에 직접 접근하는 대신 getter와 setter를 사용합니다.
- 변수 접근 시 검증, 로깅 등의 부가 작업이 필요할 때 유용합니다.
- **효과:** 변수 사용에 대한 유연성과 제어력을 높입니다.

---

## 6.7 변수 이름 바꾸기
**목적:** 변수에 명확하고 의미 있는 이름을 부여하여 코드 이해도를 높이기.

- 변수의 용도를 잘 설명하는 이름을 선택합니다.
- 코드 전반에 걸쳐 변수 이름을 일관되게 변경합니다.
- **효과:** 코드 가독성을 높이고 오해를 줄입니다.

---

## 6.8 매개변수 객체 만들기
**목적:** 관련 있는 매개변수를 하나의 객체로 그룹화하기.

- 자주 함께 사용되는 매개변수를 식별합니다.
- 해당 매개변수를 하나의 객체로 묶습니다.
- **효과:** 매개변수 개수를 줄이고 매개변수 간의 관계를 명확히 드러냅니다.

---

## 6.9 여러 함수를 클래스로 묶기
**목적:** 동일한 데이터를 처리하는 함수를 하나의 클래스로 묶기.

- 관련 있는 함수를 식별합니다.
- 클래스를 생성하고 해당 함수를 메서드로 이동시킵니다.
- 함수가 사용하는 데이터를 클래스의 인스턴스 변수로 설정합니다.
- **효과:** 코드 구조를 개선하고 객체 지향 설계로 발전시킬 수 있습니다.

---

## 6.10 여러 함수를 변환 함수로 묶기
**목적:** 데이터 변환과 관련된 함수를 하나의 변환 과정으로 묶기.

- 데이터를 변환하는 관련 함수를 식별합니다.
- 이를 하나의 변환 함수 또는 파이프라인으로 결합합니다.
- **효과:** 모듈화와 데이터 처리의 명확성을 높입니다.

---

## 6.11 단계 쪼개기
**목적:** 복잡한 프로세스를 잘 정의된 단계로 분리하기.

- 논리적으로 구분할 수 있는 프로세스의 단계를 식별합니다.
- 각 단계를 별도의 함수로 구현하고 명확한 연결을 유지합니다.
- **효과:** 코드가 단순해지고 이해 및 수정이 용이해집니다.

---

**참고:** *리팩터링: 코드 구조를 개선하는 객체지향적 방법(2판)* 마틴 파울러(Martin Fowler) 저.


